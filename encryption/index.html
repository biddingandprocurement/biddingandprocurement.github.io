<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>è¯»å– XLSX å’Œ CSV å¹¶ç”¨ Danfo åˆ†æ</title>
  <script src="xlsx.full.min.js"></script>
  <script src="danfo.js"></script>
</head>
<body>
  <h3>ä¸Šä¼  XLSX æ–‡ä»¶</h3>
  <input type="file" id="xlsxInput" accept=".xlsx" />

  <h3>ä¸Šä¼  CSV æ–‡ä»¶</h3>
  <input type="file" id="csvInput" accept=".csv" />
  
  <br><br>
  <button onclick="mergeAndDisplay()">ğŸ”„ åˆå¹¶ä¸¤ä¸ªè¡¨æ ¼</button>

  <h3>çŠ¶æ€æ—¥å¿—</h3>
  <pre id="statusLog"></pre>

  <h3>åŸå§‹è¡¨é¢„è§ˆ</h3>
  <pre id="previewData"></pre>

  <h3>åˆå¹¶ç»“æœé¢„è§ˆ</h3>
  <pre id="mergeResult"></pre>

  <script>
    let dfXlsx, dfCsv;

    function log(msg) {
      document.getElementById("statusLog").textContent += msg + "\n";
    }

    // å¤„ç† XLSX æ–‡ä»¶
    document.getElementById("xlsxInput").addEventListener("change", function (e) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function (event) {
        const data = new Uint8Array(event.target.result);
        const workbook = XLSX.read(data, { type: "array" });
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const json = XLSX.utils.sheet_to_json(worksheet, { defval: "" });

        dfXlsx = new dfd.DataFrame(json);
        log(`âœ… XLSX æ–‡ä»¶å·²åŠ è½½ï¼š${dfXlsx.shape[0]} è¡Œ`);
        displayData();
      };
      reader.readAsArrayBuffer(file);
    });

    // ä½¿ç”¨ danfo åŸç”Ÿ readCSV
    document.getElementById("csvInput").addEventListener("change", function (e) {
      const file = e.target.files[0];
      dfd.readCSV(file).then(df => {
        dfCsv = df;
        log(`âœ… CSV æ–‡ä»¶å·²åŠ è½½ï¼š${dfCsv.shape[0]} è¡Œ`);
        displayData();
      }).catch(err => {
        log("âŒ CSV åŠ è½½å¤±è´¥ï¼š" + err);
      });
    });

    // æ˜¾ç¤ºåŸå§‹æ•°æ®é¢„è§ˆ
    function displayData() {
      let out = "";
      if (dfXlsx) {
        out += "ğŸ“˜ XLSX é¢„è§ˆ:\n" + dfXlsx.head(5).toString() + "\n\n";
      }
      if (dfCsv) {
        out += "ğŸ“™ CSV é¢„è§ˆ:\n" + dfCsv.head(5).toString();
      }
      document.getElementById("previewData").textContent = out;
    }


    // function displayData() {
    //     let out = "";

    //     if (dfXlsx) {
    //         const colsXlsx = dfXlsx.columns.map(col => JSON.stringify(col)).join(", ");
    //         out += "ğŸ“˜ XLSX é¢„è§ˆ:\n" + dfXlsx.head(5).toString() + "\n\n";
    //         out += "ğŸ“˜ XLSX åˆ—å: [" + colsXlsx + "]\n\n";
    //     }

    //     if (dfCsv) {
    //         const colsCsv = dfCsv.columns.map(col => JSON.stringify(col)).join(", ");
    //         out += "ğŸ“™ CSV é¢„è§ˆ:\n" + dfCsv.head(5).toString() + "\n\n";
    //         out += "ğŸ“™ CSV åˆ—å: [" + colsCsv + "]\n";
    //     }

    //     document.getElementById("previewData").textContent = out;
    // }

    
    // åˆå¹¶é€»è¾‘
    function mergeAndDisplay() {
      if (!dfXlsx || !dfCsv) {
        alert("è¯·å…ˆä¸Šä¼  XLSX å’Œ CSV æ–‡ä»¶");
        return;
      }

      const key = "ä¾›åº”å•†åç§°";

      const uniqueXlsx = new Set(dfXlsx[key].values).size;
      const uniqueCsv = new Set(dfCsv[key].values).size;

      if (dfXlsx.shape[0] !== uniqueXlsx || dfCsv.shape[0] !== uniqueCsv) {
        alert("â—â€˜ä¾›åº”å•†åç§°â€™åˆ—åœ¨æŸä¸ªè¡¨ä¸­ä¸æ˜¯å”¯ä¸€ï¼Œæ— æ³•ä¸€ä¸€å¯¹åº”");
        return;
      }

      const dfMerged = dfd.merge({
        left: dfXlsx,
        right: dfCsv,
        on: key,
        how: "left"
      });

      window.dfMerged = dfMerged;

      const previewText = dfMerged.head(10).toString();
      document.getElementById("mergeResult").textContent = "âœ… åˆå¹¶æˆåŠŸé¢„è§ˆï¼š\n\n" + previewText;
      log("âœ… åˆå¹¶å®Œæˆï¼Œå…± " + dfMerged.shape[0] + " è¡Œ");
    }
  </script>
</body>
</html>
